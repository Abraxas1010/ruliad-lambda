<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruliad Lambda â€” Multiway Î²-Reduction Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #10002B;
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #E0AAFF;
            background: rgba(16, 0, 43, 0.9);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #7B2CBF;
            max-width: 380px;
            font-size: 13px;
        }
        #info h2 {
            margin-top: 0;
            color: #C77DFF;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #info a { color: #E0AAFF; }
        #legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #E0AAFF;
            background: rgba(16, 0, 43, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #7B2CBF;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 10px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }
        #tooltip {
            position: absolute;
            display: none;
            background: rgba(16, 0, 43, 0.95);
            color: #E0AAFF;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #9D4EDD;
            font-size: 12px;
            pointer-events: none;
            max-width: 300px;
            font-family: 'Courier New', monospace;
        }
        #stats {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #C77DFF;
            background: rgba(16, 0, 43, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #7B2CBF;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>ðŸŒŒ Ruliad Lambda</h2>
        <p>Multiway Î²-reduction graph for Î»-term:</p>
        <p style="color:#C77DFF; font-size:14px;">(Î»x.(Î»y.y x) x)</p>
        <p>Each node is a term state. Each edge is a single Î²-reduction. Multiple paths = multiple evaluation orders.</p>
        <p style="color:#9D4EDD;">Church-Rosser: All terminating paths converge.</p>
        <p><small>Drag to rotate Â· Scroll to zoom</small></p>
    </div>

    <div id="legend">
        <div class="legend-item">
            <div class="legend-color" style="background:#9D4EDD; color:#9D4EDD;"></div>
            Term (intermediate)
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background:#E0AAFF; color:#E0AAFF;"></div>
            Normal form (terminal)
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background:#FF6B6B; color:#FF6B6B;"></div>
            Initial term
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background:#7B2CBF; color:#7B2CBF;"></div>
            Î²-reduction step
        </div>
    </div>

    <div id="stats">
        <strong>Statistics</strong><br>
        Nodes: <span id="nodeCount">0</span><br>
        Edges: <span id="edgeCount">0</span><br>
        Depth: <span id="maxDepth">0</span><br>
        Confluent: <span id="confluent" style="color:#00FF88;">âœ“</span>
    </div>

    <div id="tooltip"></div>

    <script>
        // Simulated multiway graph data (represents actual Î»-calculus reductions)
        // (Î»x.(Î»y.y x) x) â†’ various reduction paths
        const nodes = [
            // Layer 0 (initial)
            { id: 0, label: '(Î»x.(Î»y.y x) x)', depth: 0, type: 'initial', x: 0, y: 0, z: 0 },

            // Layer 1 (first reductions)
            { id: 1, label: '(Î»y.y (Î»x.x)) (Î»x.x)', depth: 1, type: 'intermediate', x: -2, y: 1.5, z: 0 },
            { id: 2, label: '(Î»x.(x x) x)', depth: 1, type: 'intermediate', x: 2, y: 1.5, z: 0 },

            // Layer 2
            { id: 3, label: '(Î»x.x) (Î»x.x)', depth: 2, type: 'intermediate', x: -3, y: 3, z: -1 },
            { id: 4, label: '(Î»y.y (Î»x.x)) (Î»x.x)', depth: 2, type: 'intermediate', x: -1, y: 3, z: 1 },
            { id: 5, label: '(Î»x.x) (Î»x.x)', depth: 2, type: 'intermediate', x: 1, y: 3, z: -1 },
            { id: 6, label: '((Î»x.x) (Î»x.x))', depth: 2, type: 'intermediate', x: 3, y: 3, z: 1 },

            // Layer 3 (convergence)
            { id: 7, label: 'Î»x.x', depth: 3, type: 'terminal', x: 0, y: 5, z: 0 },
        ];

        const edges = [
            [0, 1], [0, 2],           // Initial branches
            [1, 3], [1, 4],           // Branch 1
            [2, 5], [2, 6],           // Branch 2
            [3, 7], [4, 7],           // Convergence from branch 1
            [5, 7], [6, 7],           // Convergence from branch 2
        ];

        // Update stats
        document.getElementById('nodeCount').textContent = nodes.length;
        document.getElementById('edgeCount').textContent = edges.length;
        document.getElementById('maxDepth').textContent = Math.max(...nodes.map(n => n.depth));

        // Ruliad color palette
        const colors = {
            initial: 0xFF6B6B,
            intermediate: 0x9D4EDD,
            terminal: 0xE0AAFF,
            edge: 0x7B2CBF,
            background: 0x10002B,
            glow: 0xC77DFF
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(colors.background);
        scene.fog = new THREE.FogExp2(colors.background, 0.05);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Lighting (purple-tinted)
        const ambientLight = new THREE.AmbientLight(0x7B2CBF, 0.4);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xE0AAFF, 1, 50);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x9D4EDD, 0.8, 50);
        pointLight2.position.set(-10, -5, -10);
        scene.add(pointLight2);

        // Create nodes with glow effect
        const nodeMeshes = {};
        nodes.forEach(node => {
            const size = node.type === 'terminal' ? 0.5 : (node.type === 'initial' ? 0.6 : 0.35);
            const geometry = new THREE.SphereGeometry(size, 32, 32);

            const color = colors[node.type];
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(node.x * 1.8, node.y * 1.2, node.z * 1.5);
            mesh.userData = node;
            scene.add(mesh);
            nodeMeshes[node.id] = mesh;

            // Glow sprite
            const spriteMaterial = new THREE.SpriteMaterial({
                map: createGlowTexture(color),
                color: color,
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 0.3
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size * 4, size * 4, 1);
            mesh.add(sprite);
        });

        // Create edges with gradient
        edges.forEach(([from, to]) => {
            const start = nodeMeshes[from].position;
            const end = nodeMeshes[to].position;

            const curve = new THREE.QuadraticBezierCurve3(
                start,
                new THREE.Vector3(
                    (start.x + end.x) / 2 + (Math.random() - 0.5) * 0.5,
                    (start.y + end.y) / 2,
                    (start.z + end.z) / 2 + (Math.random() - 0.5) * 0.5
                ),
                end
            );

            const points = curve.getPoints(20);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const material = new THREE.LineBasicMaterial({
                color: colors.edge,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);
        });

        // Glow texture generator
        function createGlowTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            const c = new THREE.Color(color);
            gradient.addColorStop(0, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 1)`);
            gradient.addColorStop(0.4, `rgba(${c.r*255}, ${c.g*255}, ${c.b*255}, 0.5)`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // Tooltip
        const tooltip = document.getElementById('tooltip');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Object.values(nodeMeshes));

            if (intersects.length > 0) {
                const node = intersects[0].object.userData;
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';
                tooltip.innerHTML = `
                    <strong style="color:#C77DFF;">Term:</strong><br>
                    <code style="color:#E0AAFF;">${node.label}</code><br><br>
                    <strong style="color:#C77DFF;">Depth:</strong> ${node.depth}<br>
                    <strong style="color:#C77DFF;">Type:</strong> ${node.type}
                `;
                controls.autoRotate = false;
            } else {
                tooltip.style.display = 'none';
                controls.autoRotate = true;
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Pulse terminal nodes
            const time = Date.now() * 0.002;
            nodes.forEach(node => {
                if (node.type === 'terminal') {
                    const mesh = nodeMeshes[node.id];
                    mesh.material.emissiveIntensity = 0.4 + Math.sin(time) * 0.2;
                }
            });

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
