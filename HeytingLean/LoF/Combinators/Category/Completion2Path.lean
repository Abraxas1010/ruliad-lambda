import Mathlib.Combinatorics.Quiver.Path
import HeytingLean.LoF.Combinators.Category.Completion2Cell
import HeytingLean.LoF.Combinators.Category.MultiwayCategory

/-!
# Completion2Path — non-thin 2-cells as paths in a completion-rule quiver

`Completion2Cell` provides a `Type` of explicit completion 2-cells (generated by completion squares,
closed under whiskering and vertical composition). It is intentionally a free inductive calculus,
and it is not quotiented by coherence laws.

For building higher-categorical structure, it is useful to have 2-cells whose vertical composition
is *strictly* associative/unital. We obtain this by:

1. defining a quiver of atomic completion-rule steps between parallel paths; then
2. taking `Quiver.Path` in that quiver (the free category on those generators).

This file provides:
- `Completion2Gen`: the atomic generators (whiskered completion squares, both directions),
- and `Completion2Path p q` as non-thin 2-cells (paths in the generator quiver).
-/

namespace HeytingLean
namespace LoF
namespace Combinators
namespace Category

open CategoryTheory

open HeytingLean.LoF
open HeytingLean.LoF.Comb

/-! ## Atomic generators -/

/-- Atomic completion-rule generator between parallel labeled paths:

apply a completion square (either direction) inside an arbitrary left/right context. -/
inductive Completion2Gen : {t u : Comb} → LSteps t u → LSteps t u → Type where
  | lr {t mid u : Comb} {p q : LSteps t u} (l : LSteps t mid) (c : Completion mid) (r : LSteps c.w u)
      (hp : p = LSteps.comp (LSteps.comp l (Completion.leftPath c)) r)
      (hq : q = LSteps.comp (LSteps.comp l (Completion.rightPath c)) r) :
      Completion2Gen p q
  | rl {t mid u : Comb} {p q : LSteps t u} (l : LSteps t mid) (c : Completion mid) (r : LSteps c.w u)
      (hp : p = LSteps.comp (LSteps.comp l (Completion.rightPath c)) r)
      (hq : q = LSteps.comp (LSteps.comp l (Completion.leftPath c)) r) :
      Completion2Gen p q

namespace Completion2Gen

/-- Interpret a generator as a `Completion2Cell`. -/
def to2Cell : {t u : Comb} → {p q : LSteps t u} → Completion2Gen p q → Completion2Cell p q
  | _, _, _, _, .lr l c r hp hq => by
      subst hp
      subst hq
      exact
        Completion2Cell.whisker_right
          (Completion2Cell.whisker_left l (Completion2Cell.of_completion c)) r
  | _, _, _, _, .rl l c r hp hq => by
      subst hp
      subst hq
      exact
        Completion2Cell.symm
          (Completion2Cell.whisker_right
            (Completion2Cell.whisker_left l (Completion2Cell.of_completion c)) r)

/-- A reassociation lemma used to define whiskering on generators. -/
theorem comp_assoc4 {a b mid w c : Comb} (f : LSteps a b) (l : LSteps b mid)
    (m : LSteps mid w) (r : LSteps w c) :
    LSteps.comp f (LSteps.comp (LSteps.comp l m) r) =
      LSteps.comp (LSteps.comp (LSteps.comp f l) m) r := by
  -- reassociate on the outside
  have h₀ :
      LSteps.comp f (LSteps.comp (LSteps.comp l m) r) =
        LSteps.comp (LSteps.comp f (LSteps.comp l m)) r := by
    simpa using (LSteps.comp_assoc f (LSteps.comp l m) r).symm
  -- reassociate inside
  have h₁ : LSteps.comp f (LSteps.comp l m) = LSteps.comp (LSteps.comp f l) m := by
    simpa using (LSteps.comp_assoc f l m).symm
  simp [h₀, h₁]

/-- Left whiskering of generators. -/
def whiskerLeft {a b c : Comb} (f : LSteps a b) :
    {p q : LSteps b c} → Completion2Gen p q → Completion2Gen (LSteps.comp f p) (LSteps.comp f q)
  | p, q, .lr l cell r hp hq =>
      have hp' :
          LSteps.comp f p =
            LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.leftPath cell)) r := by
        calc
          LSteps.comp f p =
              LSteps.comp f (LSteps.comp (LSteps.comp l (Completion.leftPath cell)) r) := by
                simp [hp]
          _ =
              LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.leftPath cell)) r := by
                simpa using
                  (comp_assoc4 (f := f) (l := l) (m := Completion.leftPath cell) (r := r))
      have hq' :
          LSteps.comp f q =
            LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.rightPath cell)) r := by
        calc
          LSteps.comp f q =
              LSteps.comp f (LSteps.comp (LSteps.comp l (Completion.rightPath cell)) r) := by
                simp [hq]
          _ =
              LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.rightPath cell)) r := by
                simpa using
                  (comp_assoc4 (f := f) (l := l) (m := Completion.rightPath cell) (r := r))
      Completion2Gen.lr (l := LSteps.comp f l) (c := cell) (r := r) hp' hq'
  | p, q, .rl l cell r hp hq =>
      have hp' :
          LSteps.comp f p =
            LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.rightPath cell)) r := by
        calc
          LSteps.comp f p =
              LSteps.comp f (LSteps.comp (LSteps.comp l (Completion.rightPath cell)) r) := by
                simp [hp]
          _ =
              LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.rightPath cell)) r := by
                simpa using
                  (comp_assoc4 (f := f) (l := l) (m := Completion.rightPath cell) (r := r))
      have hq' :
          LSteps.comp f q =
            LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.leftPath cell)) r := by
        calc
          LSteps.comp f q =
              LSteps.comp f (LSteps.comp (LSteps.comp l (Completion.leftPath cell)) r) := by
                simp [hq]
          _ =
              LSteps.comp (LSteps.comp (LSteps.comp f l) (Completion.leftPath cell)) r := by
                simpa using
                  (comp_assoc4 (f := f) (l := l) (m := Completion.leftPath cell) (r := r))
      Completion2Gen.rl (l := LSteps.comp f l) (c := cell) (r := r) hp' hq'

/-- Right whiskering of generators. -/
def whiskerRight {a b c : Comb} :
    {p q : LSteps a b} → Completion2Gen p q → (r : LSteps b c) →
      Completion2Gen (LSteps.comp p r) (LSteps.comp q r)
  | p, q, .lr l cell r₀ hp hq, r =>
      have hp' :
          LSteps.comp p r =
            LSteps.comp (LSteps.comp l (Completion.leftPath cell)) (LSteps.comp r₀ r) := by
        calc
          LSteps.comp p r =
              LSteps.comp (LSteps.comp (LSteps.comp l (Completion.leftPath cell)) r₀) r := by
                simp [hp]
          _ =
              LSteps.comp (LSteps.comp l (Completion.leftPath cell)) (LSteps.comp r₀ r) := by
                simpa using
                  (LSteps.comp_assoc (LSteps.comp l (Completion.leftPath cell)) r₀ r)
      have hq' :
          LSteps.comp q r =
            LSteps.comp (LSteps.comp l (Completion.rightPath cell)) (LSteps.comp r₀ r) := by
        calc
          LSteps.comp q r =
              LSteps.comp (LSteps.comp (LSteps.comp l (Completion.rightPath cell)) r₀) r := by
                simp [hq]
          _ =
              LSteps.comp (LSteps.comp l (Completion.rightPath cell)) (LSteps.comp r₀ r) := by
                simpa using
                  (LSteps.comp_assoc (LSteps.comp l (Completion.rightPath cell)) r₀ r)
      Completion2Gen.lr (l := l) (c := cell) (r := LSteps.comp r₀ r) hp' hq'
  | p, q, .rl l cell r₀ hp hq, r =>
      have hp' :
          LSteps.comp p r =
            LSteps.comp (LSteps.comp l (Completion.rightPath cell)) (LSteps.comp r₀ r) := by
        calc
          LSteps.comp p r =
              LSteps.comp (LSteps.comp (LSteps.comp l (Completion.rightPath cell)) r₀) r := by
                simp [hp]
          _ =
              LSteps.comp (LSteps.comp l (Completion.rightPath cell)) (LSteps.comp r₀ r) := by
                simpa using
                  (LSteps.comp_assoc (LSteps.comp l (Completion.rightPath cell)) r₀ r)
      have hq' :
          LSteps.comp q r =
            LSteps.comp (LSteps.comp l (Completion.leftPath cell)) (LSteps.comp r₀ r) := by
        calc
          LSteps.comp q r =
              LSteps.comp (LSteps.comp (LSteps.comp l (Completion.leftPath cell)) r₀) r := by
                simp [hq]
          _ =
              LSteps.comp (LSteps.comp l (Completion.leftPath cell)) (LSteps.comp r₀ r) := by
                simpa using
                  (LSteps.comp_assoc (LSteps.comp l (Completion.leftPath cell)) r₀ r)
      Completion2Gen.rl (l := l) (c := cell) (r := LSteps.comp r₀ r) hp' hq'

end Completion2Gen

/-! ## The generator quiver (as explicit data, not a global instance) -/

/-- The completion-rule generator quiver on a fixed hom-type `a ⟶ b`.

We keep this as explicit data (not an `instance`) so the 2-cell category structure on `a ⟶ b`
can later use the `⟶`-notation for *2-cells* without clashing with the generator arrows. -/
def completion2GenQuiver (a b : MWObj) : Quiver (a ⟶ b) where
  Hom p q := Completion2Gen p q

/-! ## 2-cells as paths in the generator quiver -/

/-- Non-thin 2-cells between parallel paths: paths in the completion-rule generator quiver. -/
abbrev Completion2Path {a b : MWObj} (p q : a ⟶ b) : Type :=
  @Quiver.Path (a ⟶ b) (completion2GenQuiver a b) p q

namespace Completion2Path

/-- Identity 2-cell (empty generator path). -/
def id {a b : MWObj} (p : a ⟶ b) : Completion2Path p p := by
  letI : Quiver (a ⟶ b) := completion2GenQuiver a b
  exact .nil

/-- View an equality of 1-morphisms as a 2-cell (an empty generator path after rewriting). -/
def eqToHom {a b : MWObj} {p q : a ⟶ b} (h : p = q) : Completion2Path p q := by
  letI : Quiver (a ⟶ b) := completion2GenQuiver a b
  cases h
  exact .nil

/-- Vertical composition of 2-cells (concatenation of generator paths). -/
def vcomp {a b : MWObj} {p q r : a ⟶ b} (η : Completion2Path p q) (θ : Completion2Path q r) :
    Completion2Path p r := by
  letI : Quiver (a ⟶ b) := completion2GenQuiver a b
  exact Quiver.Path.comp η θ

/-- Interpret a `Completion2Path` as a `Completion2Cell`. -/
def to2Cell {a b : MWObj} {p q : a ⟶ b} (η : Completion2Path p q) : Completion2Cell p q := by
  induction η with
  | nil =>
      exact Completion2Cell.refl p
  | @cons r s η e ih =>
      exact Completion2Cell.trans ih (Completion2Gen.to2Cell e)

/-- Forget a `Completion2Path` to the Prop-valued completion homotopy relation. -/
def toHomotopy {a b : MWObj} {p q : a ⟶ b} (η : Completion2Path p q) : CompletionHomotopy p q :=
  Completion2Cell.toHomotopy (to2Cell η)

/-! ### Whiskering -/

/-- Left whiskering of `Completion2Path`. -/
def whiskerLeft {a b c : MWObj} (f : a ⟶ b) {p q : b ⟶ c} (η : Completion2Path p q) :
    Completion2Path (f ≫ p) (f ≫ q) := by
  -- Provide the generator quiver instances needed to construct `Quiver.Path` terms.
  letI : Quiver (b ⟶ c) := completion2GenQuiver b c
  letI : Quiver (a ⟶ c) := completion2GenQuiver a c
  induction η with
  | nil =>
      exact .nil
  | @cons r s η e ih =>
      exact
        .cons ih (Completion2Gen.whiskerLeft (a := a.term) (b := b.term) (c := c.term) f e)

/-- Right whiskering of `Completion2Path`. -/
def whiskerRight {a b c : MWObj} {p q : a ⟶ b} (η : Completion2Path p q) (g : b ⟶ c) :
    Completion2Path (p ≫ g) (q ≫ g) := by
  letI : Quiver (a ⟶ b) := completion2GenQuiver a b
  letI : Quiver (a ⟶ c) := completion2GenQuiver a c
  induction η with
  | nil =>
      exact .nil
  | @cons r s η e ih =>
      exact
        .cons ih (Completion2Gen.whiskerRight (a := a.term) (b := b.term) (c := c.term) e g)

/-- A completion square yields a length-1 `Completion2Path` 2-cell. -/
def of_completion {t : Comb} (c : Completion t) :
    Completion2Path (a := ⟨t⟩) (b := ⟨c.w⟩) (Completion.leftPath c) (Completion.rightPath c) := by
  let a : MWObj := ⟨t⟩
  let b : MWObj := ⟨c.w⟩
  letI : Quiver (a ⟶ b) := completion2GenQuiver a b
  refine Quiver.Path.cons Quiver.Path.nil ?_
  refine
    Completion2Gen.lr (t := t) (mid := t) (u := c.w)
      (l := LSteps.refl t) (c := c) (r := LSteps.refl c.w) ?_ ?_
  · simp
  · simp

end Completion2Path

end Category
end Combinators
end LoF
end HeytingLean
