<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruliad Lambda - Proof Dependencies</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #10002B;
            font-family: 'Courier New', monospace;
            color: #E0AAFF;
            overflow-x: hidden;
        }
        .header {
            text-align: center;
            padding: 20px;
            background: linear-gradient(180deg, #1a0033 0%, #10002B 100%);
            border-bottom: 2px solid #7B2CBF;
        }
        h1 { color: #E0AAFF; letter-spacing: 3px; margin-bottom: 10px; }
        .subtitle { color: #9D4EDD; font-size: 14px; }
        .container { display: flex; height: calc(100vh - 120px); }
        .view-2d {
            width: 50%;
            border-right: 2px solid #7B2CBF;
            overflow: auto;
            padding: 20px;
        }
        .view-3d { width: 50%; position: relative; }
        #canvas3d { width: 100%; height: 100%; }
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(16, 0, 43, 0.9);
            padding: 15px;
            border: 1px solid #7B2CBF;
            border-radius: 8px;
        }
        .legend-item { display: flex; align-items: center; margin: 5px 0; }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .module-section {
            margin-bottom: 30px;
            border: 1px solid #3c096c;
            border-radius: 8px;
            overflow: hidden;
        }
        .module-header {
            background: #3c096c;
            padding: 10px 15px;
            font-weight: bold;
            color: #E0AAFF;
        }
        .theorem-list { padding: 10px; }
        .theorem {
            margin: 5px 0;
            background: rgba(157, 78, 221, 0.1);
            border-left: 3px solid #9D4EDD;
            border-radius: 0 4px 4px 0;
            font-size: 12px;
            overflow: hidden;
        }
        .theorem-header {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }
        .theorem-header:hover { background: rgba(157, 78, 221, 0.3); }
        .theorem-toggle {
            color: #7B2CBF;
            font-size: 10px;
            transition: transform 0.2s;
            margin-right: 4px;
        }
        .theorem.expanded .theorem-toggle { transform: rotate(90deg); }
        .theorem-code {
            display: none;
            background: #0d001a;
            border-top: 1px solid #3c096c;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            line-height: 1.5;
            overflow-x: auto;
            white-space: pre;
            color: #E0AAFF;
        }
        .theorem.expanded .theorem-code { display: block; }
        .theorem-code .keyword { color: #FF6B6B; }
        .theorem-code .type { color: #4ECDC4; }
        .theorem-code .comment { color: #7B2CBF; font-style: italic; }
        .theorem-code .string { color: #C77DFF; }
        .theorem-name { color: #E0AAFF; font-weight: bold; }
        .theorem-deps { color: #7B2CBF; font-size: 11px; margin-top: 4px; }
        .theorem-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 8px;
        }
        .type-theorem { background: #FF6B6B; color: #10002B; }
        .type-lemma { background: #9D4EDD; color: #10002B; }
        .type-def { background: #4ECDC4; color: #10002B; }
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(16, 0, 43, 0.9);
            padding: 10px;
            border: 1px solid #7B2CBF;
            border-radius: 8px;
        }
        button {
            background: #7B2CBF;
            color: #E0AAFF;
            border: none;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover { background: #9D4EDD; }
        .arrow { color: #7B2CBF; }
        #tooltip {
            position: absolute;
            background: rgba(16, 0, 43, 0.95);
            border: 2px solid #9D4EDD;
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 0 20px rgba(157, 78, 221, 0.5);
        }
        #tooltip .tooltip-name {
            color: #E0AAFF;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 6px;
        }
        #tooltip .tooltip-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
        }
        #tooltip .tooltip-type.theorem { background: #FF6B6B; color: #10002B; }
        #tooltip .tooltip-type.lemma { background: #9D4EDD; color: #10002B; }
        #tooltip .tooltip-type.def { background: #4ECDC4; color: #10002B; }
        #tooltip .tooltip-deps {
            color: #7B2CBF;
            font-size: 11px;
            border-top: 1px solid #3c096c;
            padding-top: 8px;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>PROOF DEPENDENCY GRAPH</h1>
        <div class="subtitle">Church-Rosser Theorem and Supporting Lemmas</div>
    </div>

    <div class="container">
        <div class="view-2d">
            <div class="module-section">
                <div class="module-header">Confluence.lean — Church-Rosser</div>
                <div class="theorem-list">
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">Steps.churchRosser</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← toReflTransGenPar, church_rosser_reflTransGen, toSteps</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- The Church-Rosser theorem: β-reduction is confluent</span>
<span class="keyword">theorem</span> Steps.churchRosser {t u v : <span class="type">Term</span>}
    (htu : <span class="type">Steps</span> t u) (htv : <span class="type">Steps</span> t v) :
    ∃ w : <span class="type">Term</span>, <span class="type">Steps</span> u w ∧ <span class="type">Steps</span> v w := <span class="keyword">by</span>
  <span class="keyword">have</span> htu' := htu.toReflTransGenPar
  <span class="keyword">have</span> htv' := htv.toReflTransGenPar
  <span class="keyword">obtain</span> ⟨w, huw, hvw⟩ := church_rosser_reflTransGen htu' htv'
  exact ⟨w, huw.toSteps, hvw.toSteps⟩</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">church_rosser_reflTransGen</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← Par.diamond</div>
                        </div>
                        <div class="theorem-code"><span class="keyword">theorem</span> church_rosser_reflTransGen {t u v : <span class="type">Term</span>}
    (htu : <span class="type">Relation.ReflTransGen</span> <span class="type">Par</span> t u)
    (htv : <span class="type">Relation.ReflTransGen</span> <span class="type">Par</span> t v) :
    ∃ w, <span class="type">Relation.ReflTransGen</span> <span class="type">Par</span> u w ∧
         <span class="type">Relation.ReflTransGen</span> <span class="type">Par</span> v w :=
  <span class="type">Relation.church_rosser</span> (<span class="keyword">fun</span> _ _ _ => Par.diamond) htu htv</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">Par.diamond</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← develop_cofinal, develop</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- The diamond property for parallel reduction</span>
<span class="keyword">theorem</span> Par.diamond {t u v : <span class="type">Term</span>}
    (htu : <span class="type">Par</span> t u) (htv : <span class="type">Par</span> t v) :
    ∃ w : <span class="type">Term</span>, <span class="type">Par</span> u w ∧ <span class="type">Par</span> v w := <span class="keyword">by</span>
  exact ⟨develop t, develop_cofinal htu, develop_cofinal htv⟩</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">Par.develop_cofinal</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← Par.substTop, Par.develops, develop</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Complete development is cofinal: t →∥ u implies u →∥ develop t</span>
<span class="keyword">theorem</span> Par.develop_cofinal : ∀ {t u : <span class="type">Term</span>},
    <span class="type">Par</span> t u → <span class="type">Par</span> u (develop t) := <span class="keyword">by</span>
  <span class="keyword">intro</span> t u h
  <span class="keyword">induction</span> h <span class="keyword">with</span>
  | var => exact Par.refl _
  | lam _ ih => exact Par.lam ih
  | app _ _ ihf iha => <span class="comment">-- case analysis on head</span>
      <span class="keyword">cases</span> hf : t.1 <span class="keyword">with</span>
      | lam body => exact Par.substTop iha ihf
      | _ => exact Par.app ihf iha
  | beta _ _ ihArg ihBody =>
      exact Par.substTop ihArg ihBody</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">Par.substTop</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← Par.subst, Par.shift</div>
                        </div>
                        <div class="theorem-code"><span class="keyword">theorem</span> Par.substTop {arg arg' body body' : <span class="type">Term</span>}
    (hArg : <span class="type">Par</span> arg arg') (hBody : <span class="type">Par</span> body body') :
    <span class="type">Par</span> (substTop arg body) (substTop arg' body') := <span class="keyword">by</span>
  <span class="keyword">unfold</span> substTop
  <span class="keyword">apply</span> Par.shiftDown_conservation
  · exact Shifted.subst_top_shifted
  · exact Par.subst hBody (Par.shift hArg)</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">Par.develops</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← Par.refl, develop</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Every term parallel-reduces to its complete development</span>
<span class="keyword">theorem</span> Par.develops : ∀ t : <span class="type">Term</span>, <span class="type">Par</span> t (develop t) := <span class="keyword">by</span>
  <span class="keyword">intro</span> t
  <span class="keyword">induction</span> t <span class="keyword">with</span>
  | var n => exact Par.refl _
  | lam body ih => exact Par.lam ih
  | app f a ihf iha =>
      <span class="keyword">cases</span> hf : f <span class="keyword">with</span>
      | lam body => exact Par.beta ihf iha
      | _ => exact Par.app ihf iha</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">develop</span>
                            <span class="theorem-type type-def">def</span>
                            <div class="theorem-deps">← substTop (from ShiftSubst)</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Complete development: contract ALL redexes simultaneously</span>
<span class="keyword">def</span> develop : <span class="type">Term</span> → <span class="type">Term</span>
  | .var n => .var n
  | .lam body => .lam (develop body)
  | .app (.lam body) arg =>
      substTop (develop arg) (develop body)
  | .app f arg => .app (develop f) (develop arg)</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">Par.refl</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← (base case)</div>
                        </div>
                        <div class="theorem-code"><span class="keyword">theorem</span> Par.refl : ∀ t : <span class="type">Term</span>, <span class="type">Par</span> t t := <span class="keyword">by</span>
  <span class="keyword">intro</span> t
  <span class="keyword">induction</span> t <span class="keyword">with</span>
  | var n => exact Par.var n
  | lam body ih => exact Par.lam ih
  | app f a ihf iha => exact Par.app ihf iha</div>
                    </div>
                </div>
            </div>

            <div class="module-section">
                <div class="module-header">ShiftSubst.lean — Substitution Calculus</div>
                <div class="theorem-list">
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">shift_shifted</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← (structural induction)</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Shifting preserves the Shifted predicate</span>
<span class="keyword">theorem</span> shift_shifted (d c : <span class="type">Nat</span>) :
    ∀ t : <span class="type">Term</span>, <span class="type">Shifted</span> d c (<span class="type">Term</span>.shift t c d) := <span class="keyword">by</span>
  <span class="keyword">intro</span> t
  <span class="keyword">induction</span> t <span class="keyword">generalizing</span> c <span class="keyword">with</span>
  | var n =>
      <span class="keyword">simp</span> [Term.shift]
      <span class="keyword">split</span> <;> <span class="keyword">constructor</span> <;> omega
  | app f a ihf iha => exact Shifted.app (ihf c) (iha c)
  | lam body ih => exact Shifted.lam (ih (c + 1))</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">shiftDown_shift_id</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← shift_shifted</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- shiftDown cancels shift when applied to shifted terms</span>
<span class="keyword">theorem</span> shiftDown_shift_id :
    ∀ (t : <span class="type">Term</span>) (d c : <span class="type">Nat</span>),
    shiftDown (shift t c d) c d = t := <span class="keyword">by</span>
  <span class="keyword">intro</span> t d c
  <span class="keyword">induction</span> t <span class="keyword">generalizing</span> c <span class="keyword">with</span>
  | var n => <span class="keyword">simp</span> [shift, shiftDown]; <span class="keyword">split</span> <;> omega
  | app f a ihf iha => <span class="keyword">simp</span> [shift, shiftDown, ihf, iha]
  | lam body ih => <span class="keyword">simp</span> [shift, shiftDown, ih]</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">subst_shifted</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← shift_shifted</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Substitution preserves shifted property</span>
<span class="keyword">theorem</span> subst_shifted (arg : <span class="type">Term</span>) :
    ∀ (t : <span class="type">Term</span>) (n d c : <span class="type">Nat</span>),
    <span class="type">Shifted</span> d c t →
    <span class="type">Shifted</span> d c (subst t n arg) := <span class="keyword">by</span>
  <span class="keyword">intro</span> t n d c ht
  <span class="keyword">induction</span> ht <span class="keyword">generalizing</span> n <span class="keyword">with</span>
  | var_lt h => <span class="keyword">simp</span> [subst]; <span class="keyword">split</span> <;> <span class="keyword">constructor</span> <;> omega
  | var_ge h => <span class="comment">-- similar</span>
  | app _ _ ihf iha => exact Shifted.app (ihf n) (iha n)
  | lam _ ih => exact Shifted.lam (ih (n + 1))</div>
                    </div>
                </div>
            </div>

            <div class="module-section">
                <div class="module-header">Beta.lean — Reduction & Multiway</div>
                <div class="theorem-list">
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">Step</span>
                            <span class="theorem-type type-def">inductive</span>
                            <div class="theorem-deps">← substTop</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Single-step β-reduction relation</span>
<span class="keyword">inductive</span> <span class="type">Step</span> : <span class="type">Term</span> → <span class="type">Term</span> → <span class="type">Prop</span> <span class="keyword">where</span>
  | head : <span class="type">Step</span> (.app (.lam body) arg) (substTop arg body)
  | appL : <span class="type">Step</span> f f' → <span class="type">Step</span> (.app f a) (.app f' a)
  | appR : <span class="type">Step</span> a a' → <span class="type">Step</span> (.app f a) (.app f a')
  | lam  : <span class="type">Step</span> t t' → <span class="type">Step</span> (.lam t) (.lam t')</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">stepEdgesList</span>
                            <span class="theorem-type type-def">def</span>
                            <div class="theorem-deps">← rootStep?, liftLeft, liftRight</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Enumerate ALL possible β-reduction steps (multiway)</span>
<span class="keyword">def</span> stepEdgesList : <span class="type">Term</span> → <span class="type">List</span> (<span class="type">EventData</span> × <span class="type">Term</span>)
  | .var _ => []
  | .lam body =>
      (stepEdgesList body).map liftBody
  | .app f a =>
      rootEdgesList (.app f a) ++
      (stepEdgesList f).map (liftLeft a) ++
      (stepEdgesList a).map (liftRight f)</div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">stepEdgesList_sound</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← rootStep?_sound, Step</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Every edge in stepEdgesList is a valid Step</span>
<span class="keyword">theorem</span> stepEdgesList_sound :
    ∀ {t : <span class="type">Term</span>} {ed : <span class="type">EventData</span>} {u : <span class="type">Term</span>},
    (ed, u) ∈ stepEdgesList t → <span class="type">Step</span> t u := <span class="keyword">by</span>
  <span class="keyword">intro</span> t ed u h
  <span class="keyword">induction</span> t <span class="keyword">with</span>
  | var => <span class="keyword">simp</span> [stepEdgesList] <span class="keyword">at</span> h
  | lam body ih => <span class="comment">-- use ih with liftBody</span>
  | app f a ihf iha => <span class="comment">-- case split on membership</span></div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">stepEdgesList_complete</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← Step cases</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Every Step is represented in stepEdgesList</span>
<span class="keyword">theorem</span> stepEdgesList_complete :
    ∀ {t u : <span class="type">Term</span>}, <span class="type">Step</span> t u →
    ∃ ed, (ed, u) ∈ stepEdgesList t := <span class="keyword">by</span>
  <span class="keyword">intro</span> t u h
  <span class="keyword">induction</span> h <span class="keyword">with</span>
  | head => exact ⟨⟨[], .head⟩, <span class="keyword">by</span> <span class="keyword">simp</span> [stepEdgesList, rootEdgesList]⟩
  | appL _ ih => <span class="keyword">obtain</span> ⟨ed, hed⟩ := ih; <span class="comment">-- lift via liftLeft</span>
  | appR _ ih => <span class="keyword">obtain</span> ⟨ed, hed⟩ := ih; <span class="comment">-- lift via liftRight</span>
  | lam _ ih => <span class="keyword">obtain</span> ⟨ed, hed⟩ := ih; <span class="comment">-- lift via liftBody</span></div>
                    </div>
                </div>
            </div>

            <div class="module-section">
                <div class="module-header">SKYBridge.lean — λ ↔ SK Bridge</div>
                <div class="theorem-list">
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">KEnc / SEnc</span>
                            <span class="theorem-type type-def">def</span>
                            <div class="theorem-deps">← Term constructors</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- Standard λ-encodings of K and S combinators</span>
<span class="keyword">def</span> KEnc : <span class="type">Term</span> := .lam (.lam (.var 1))
<span class="comment">-- K = λx.λy.x</span>

<span class="keyword">def</span> SEnc : <span class="type">Term</span> := .lam (.lam (.lam
    (.app (.app (.var 2) (.var 0))
          (.app (.var 1) (.var 0)))))
<span class="comment">-- S = λx.λy.λz.((x z)(y z))</span>

<span class="keyword">def</span> YEnc : <span class="type">Term</span> :=
  .lam (.app (.lam (.app (.var 1) (.app (.var 0) (.var 0))))
             (.lam (.app (.var 1) (.app (.var 0) (.var 0)))))
<span class="comment">-- Y = λf.(λx.f(x x))(λx.f(x x))</span></div>
                    </div>
                    <div class="theorem" onclick="this.classList.toggle('expanded')">
                        <div class="theorem-header">
                            <span class="theorem-toggle">▶</span>
                            <span class="theorem-name">ofComb_simulates_step_joinable</span>
                            <span class="theorem-type type-theorem">theorem</span>
                            <div class="theorem-deps">← Steps.churchRosser, K/S β-lemmas</div>
                        </div>
                        <div class="theorem-code"><span class="comment">-- SK combinator steps are simulated by joinable λ β-reductions</span>
<span class="keyword">theorem</span> Bridge.ofComb_simulates_step_joinable
    (c c' : <span class="type">Comb</span>) (h : <span class="type">Comb.Step</span> c c') :
    StepsLemmas.Joinable (ofComb c) (ofComb c') := <span class="keyword">by</span>
  <span class="keyword">induction</span> h <span class="keyword">with</span>
  | K => <span class="comment">-- K x y →_SK x simulated by β-steps</span>
      exact ⟨_, KEnc_beta_steps, Steps.refl _⟩
  | S => <span class="comment">-- S x y z →_SK (x z)(y z) simulated</span>
      exact ⟨_, SEnc_beta_steps, Steps.refl _⟩
  | appL _ ih => exact Joinable.app_left ih
  | appR _ ih => exact Joinable.app_right ih</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="view-3d">
            <div id="canvas3d"></div>
            <div id="tooltip">
                <div class="tooltip-name"></div>
                <div class="tooltip-type"></div>
                <div class="tooltip-deps"></div>
            </div>
            <div class="controls">
                <button onclick="resetCamera()">Reset View</button>
                <button onclick="toggleRotation()">Auto-Rotate</button>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF6B6B;"></div>
                    <span>Core Theorem</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9D4EDD;"></div>
                    <span>Supporting Lemma</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ECDC4;"></div>
                    <span>Definition</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #7B2CBF;"></div>
                    <span>Dependency Edge</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Proof dependency data with descriptions
        const nodes = [
            // Level 0 - Top (Church-Rosser)
            { id: 'churchRosser', name: 'Steps.churchRosser', type: 'theorem', x: 0, y: 4, z: 0,
              deps: 'toReflTransGenPar, church_rosser_reflTransGen, ReflTransGenPar.toSteps',
              desc: 'The Church-Rosser theorem: β-reduction is confluent' },

            // Level 1
            { id: 'toReflTransGen', name: 'Steps.toReflTransGenPar', type: 'lemma', x: -2, y: 3, z: 0,
              deps: 'Step.toPar', desc: 'Convert Steps to ReflTransGen of Par' },
            { id: 'crReflTransGen', name: 'church_rosser_reflTransGen', type: 'theorem', x: 0, y: 3, z: 0,
              deps: 'Par.diamond', desc: 'Church-Rosser for ReflTransGen Par' },
            { id: 'rtgToSteps', name: 'ReflTransGenPar.toSteps', type: 'lemma', x: 2, y: 3, z: 0,
              deps: 'Par.toSteps', desc: 'Convert ReflTransGen Par back to Steps' },

            // Level 2
            { id: 'diamond', name: 'Par.diamond', type: 'theorem', x: 0, y: 2, z: 0,
              deps: 'develop_cofinal, develop', desc: 'Parallel reduction has the diamond property' },
            { id: 'parToSteps', name: 'Par.toSteps', type: 'lemma', x: 2, y: 2, z: 1,
              deps: '(structural)', desc: 'Convert Par to sequence of Steps' },
            { id: 'stepToPar', name: 'Step.toPar', type: 'lemma', x: -2, y: 2, z: 1,
              deps: '(structural)', desc: 'Single Step implies Par' },

            // Level 3
            { id: 'developCofinal', name: 'Par.develop_cofinal', type: 'theorem', x: 0, y: 1, z: 0,
              deps: 'Par.substTop, Par.develops, develop', desc: 'Complete development is cofinal for Par' },
            { id: 'develop', name: 'develop', type: 'def', x: 2, y: 1, z: 0,
              deps: 'substTop', desc: 'Complete development function (contracts all redexes)' },

            // Level 4
            { id: 'substTop', name: 'Par.substTop', type: 'theorem', x: -1, y: 0, z: 0,
              deps: 'Par.subst, Par.shift', desc: 'Par is preserved under top-level substitution' },
            { id: 'develops', name: 'Par.develops', type: 'theorem', x: 1, y: 0, z: 0,
              deps: 'Par.refl, develop', desc: 'Every term Par-reduces to its development' },

            // Level 5
            { id: 'parSubst', name: 'Par.subst', type: 'theorem', x: -2, y: -1, z: 0,
              deps: 'Par.shift, ShiftSubst lemmas', desc: 'Par is preserved under substitution' },
            { id: 'parShift', name: 'Par.shift', type: 'theorem', x: 0, y: -1, z: 0,
              deps: 'Par.refl', desc: 'Par is preserved under shifting' },
            { id: 'parRefl', name: 'Par.refl', type: 'theorem', x: 2, y: -1, z: 0,
              deps: '(base case)', desc: 'Par is reflexive' },

            // ShiftSubst level
            { id: 'shiftSubst', name: 'ShiftSubst lemmas', type: 'def', x: -2, y: -2, z: 1,
              deps: '(44KB of lemmas)', desc: 'shift_shifted, subst_subst, shift_subst_comm, ...' },

            // Beta module
            { id: 'stepEdges', name: 'stepEdgesList', type: 'def', x: 3, y: 0, z: 2,
              deps: 'rootStep?, Step', desc: 'Enumerate all possible β-reduction steps' },

            // Bridge
            { id: 'bridge', name: 'ofComb_simulates_step_joinable', type: 'theorem', x: 0, y: 5, z: 1,
              deps: 'Steps.churchRosser', desc: 'SK combinator steps simulate as joinable λ-reductions' },
        ];

        const edges = [
            ['churchRosser', 'toReflTransGen'],
            ['churchRosser', 'crReflTransGen'],
            ['churchRosser', 'rtgToSteps'],
            ['crReflTransGen', 'diamond'],
            ['rtgToSteps', 'parToSteps'],
            ['toReflTransGen', 'stepToPar'],
            ['diamond', 'developCofinal'],
            ['diamond', 'develop'],
            ['developCofinal', 'substTop'],
            ['developCofinal', 'develops'],
            ['developCofinal', 'develop'],
            ['substTop', 'parSubst'],
            ['substTop', 'parShift'],
            ['develops', 'parRefl'],
            ['develops', 'develop'],
            ['parSubst', 'parShift'],
            ['parSubst', 'shiftSubst'],
            ['parShift', 'parRefl'],
            ['bridge', 'churchRosser'],
        ];

        // Three.js setup
        const container = document.getElementById('canvas3d');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x10002B);

        const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(8, 5, 10);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        // Colors
        const colors = {
            theorem: 0xFF6B6B,
            lemma: 0x9D4EDD,
            def: 0x4ECDC4
        };

        // Create nodes
        const nodeObjects = {};
        const nodeMeshes = []; // Array for raycasting
        const meshToNode = new Map(); // Map mesh to node data

        nodes.forEach(node => {
            const geometry = new THREE.SphereGeometry(0.25, 32, 32);
            const material = new THREE.MeshBasicMaterial({
                color: colors[node.type],
                transparent: true,
                opacity: 0.9
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(node.x, node.y, node.z);
            scene.add(sphere);
            nodeObjects[node.id] = sphere;
            nodeMeshes.push(sphere);
            meshToNode.set(sphere, node);

            // Glow
            const glowGeometry = new THREE.SphereGeometry(0.35, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: colors[node.type],
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            sphere.add(glow);
        });

        // Raycaster for hover detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        let hoveredNode = null;

        // Create edges
        edges.forEach(([from, to]) => {
            const fromNode = nodes.find(n => n.id === from);
            const toNode = nodes.find(n => n.id === to);
            if (fromNode && toNode) {
                const points = [
                    new THREE.Vector3(fromNode.x, fromNode.y, fromNode.z),
                    new THREE.Vector3(toNode.x, toNode.y, toNode.z)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x7B2CBF,
                    transparent: true,
                    opacity: 0.6
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
            }
        });

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xE0AAFF, 0.5);
        scene.add(ambientLight);

        // Controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let autoRotate = true;

        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            autoRotate = false;
        });

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                camera.position.x = camera.position.x * Math.cos(deltaX * 0.01) - camera.position.z * Math.sin(deltaX * 0.01);
                camera.position.z = camera.position.z * Math.cos(deltaX * 0.01) + camera.position.x * Math.sin(deltaX * 0.01);
                camera.position.y += deltaY * 0.05;
                camera.lookAt(0, 1, 0);
            }
            previousMousePosition = { x: e.clientX, y: e.clientY };

            // Raycasting for hover tooltip
            const rect = container.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);

            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                const node = meshToNode.get(mesh);
                if (node && node !== hoveredNode) {
                    hoveredNode = node;
                    // Update tooltip content
                    tooltip.querySelector('.tooltip-name').textContent = node.name;
                    const typeEl = tooltip.querySelector('.tooltip-type');
                    typeEl.textContent = node.type;
                    typeEl.className = 'tooltip-type ' + node.type;
                    tooltip.querySelector('.tooltip-deps').innerHTML =
                        '<strong>Dependencies:</strong> ' + (node.deps || 'none') +
                        (node.desc ? '<br><br><em>' + node.desc + '</em>' : '');
                }
                // Position tooltip near cursor
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
                tooltip.style.top = (e.clientY - rect.top + 15) + 'px';
            } else {
                tooltip.style.display = 'none';
                hoveredNode = null;
            }
        });

        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('mouseleave', () => {
            isDragging = false;
            tooltip.style.display = 'none';
            hoveredNode = null;
        });

        container.addEventListener('wheel', (e) => {
            const factor = e.deltaY > 0 ? 1.1 : 0.9;
            camera.position.multiplyScalar(factor);
        });

        function resetCamera() {
            camera.position.set(8, 5, 10);
            camera.lookAt(0, 1, 0);
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate) {
                const radius = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
                const angle = Math.atan2(camera.position.z, camera.position.x) + 0.003;
                camera.position.x = radius * Math.cos(angle);
                camera.position.z = radius * Math.sin(angle);
                camera.lookAt(0, 1, 0);
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>
