import Mathlib.CategoryTheory.Functor.Basic
import HeytingLean.LoF.Combinators.Category.CompletionHomotopy

/-!
# CompletionQuotient — quotienting the multiway path category by completion homotopy

`CompletionHomotopy` is a 2-cell relation on labeled multi-step paths `LSteps` generated by completion
cells and closed under whiskering. This file uses that congruence to form a new path category whose
hom-sets are quotiented by completion homotopy.

This is a conservative “gluing” layer: it does not claim global confluence or termination, but it
allows us to identify paths related by explicit completion squares (and their whiskered closures).
-/

namespace HeytingLean
namespace LoF
namespace Combinators
namespace Category

open HeytingLean.LoF
open HeytingLean.LoF.Comb

/-! ## Objects -/

/-- Wrapper for SKY terms when we want the **completion-quotiented** path category. -/
structure MWQuotObj where
  term : Comb
deriving DecidableEq, Repr

namespace CompletionHomotopy

theorem comp_congr {t u v : Comb} {p p' : LSteps t u} {q q' : LSteps u v} :
    CompletionHomotopy p p' → CompletionHomotopy q q' →
      CompletionHomotopy (LSteps.comp p q) (LSteps.comp p' q') := by
  intro hp hq
  refine CompletionHomotopy.trans (CompletionHomotopy.whisker_right hp q) ?_
  exact CompletionHomotopy.whisker_left p' hq

end CompletionHomotopy

/-! ## The completion-quotiented path category -/

instance : CategoryTheory.Category MWQuotObj where
  Hom X Y := Quotient (inferInstance : Setoid (LSteps X.term Y.term))
  id X := Quotient.mk _ (LSteps.refl X.term)
  comp f g :=
    Quotient.liftOn₂ f g
      (fun p q => Quotient.mk _ (LSteps.comp p q))
      (by
        intro p p' q q' hp hq
        apply Quotient.sound
        exact CompletionHomotopy.comp_congr (t := _) (u := _) (v := _) hp hq)
  id_comp := by
    intro X Y f
    refine Quotient.inductionOn f ?_
    intro p
    rfl
  comp_id := by
    intro X Y f
    refine Quotient.inductionOn f ?_
    intro p
    simp [LSteps.comp_refl_right]
  assoc := by
    intro X Y Z W f g h
    refine Quotient.inductionOn₃ f g h ?_
    intro p q r
    change
      Quotient.mk _ (LSteps.comp (LSteps.comp p q) r) =
        Quotient.mk _ (LSteps.comp p (LSteps.comp q r))
    simp [LSteps.comp_assoc]

/-! ## The quotient functor -/

/-- The evident functor from the labeled path category to its completion-quotient. -/
def completionQuotientFunctor : CategoryTheory.Functor MWObj MWQuotObj where
  obj X := ⟨X.term⟩
  map {X Y} f := Quotient.mk _ f
  map_id := by
    intro X
    rfl
  map_comp := by
    intro X Y Z f g
    rfl

namespace CompletionHomotopy

/-- Any completion cell identifies its boundary paths in the quotient. -/
theorem quot_eq_of_completion {t : Comb} (c : Completion t) :
    Quotient.mk (s := (inferInstance : Setoid (LSteps t c.w))) (Completion.leftPath c) =
      Quotient.mk (s := (inferInstance : Setoid (LSteps t c.w))) (Completion.rightPath c) := by
  apply Quotient.sound
  exact CompletionHomotopy.of_completion c

end CompletionHomotopy

end Category
end Combinators
end LoF
end HeytingLean
