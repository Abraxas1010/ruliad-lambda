import Mathlib.CategoryTheory.CommSq
import HeytingLean.LoF.Combinators.Category.MultiwayCategory
import HeytingLean.LoF.Combinators.Category.HigherCells
import HeytingLean.LoF.Combinators.Category.Completion2Cell
import HeytingLean.LoF.Combinators.Category.CompletionHomotopy

/-!
# NFoldCategory — a strict double category skeleton for SKY multiway paths

Mathlib does not currently ship a general “double category” API, but it *does* provide an
excellent commutative-square API (`CategoryTheory.CommSq`) with horizontal/vertical pasting.

For Phase 3.1 of the SKY–Heyting–∞-groupoid program we:

1. define a minimal record `DoubleCategoryData` (objects, horizontal/vertical morphisms, cells);
2. instantiate it for any category using commutative squares;
3. specialize to the SKY multiway path category (`MWObj`) built from labeled rewrite paths.

This gives a **strict double category of commutative squares** of rewrite paths:

* objects: SKY terms (wrapped as `MWObj`)
* horizontal morphisms: labeled multi-step paths (`LSteps`)
* vertical morphisms: labeled multi-step paths (`LSteps`)
* 2-cells: commuting squares of paths (via `CommSq`)

This is a conservative “first double structure”: it does **not** attempt to model completion-rule
homotopies or non-confluence as invertible 2-cells. Those are future refinements.

We also define a second, more flexible cell predicate for SKY paths where squares commute
**up to `CompletionHomotopy`** (generated by completion cells and whiskering). This is a
“weak square” layer better aligned with completion-rule narratives.
-/

namespace HeytingLean
namespace LoF
namespace Combinators
namespace Category

open CategoryTheory

universe u v w

/-- Minimal data for a (strict) double category: objects, two classes of 1-morphisms,
and a type of 2-cells with a square boundary. -/
structure DoubleCategoryData where
  Obj : Type u
  H : Obj → Obj → Type v
  V : Obj → Obj → Type v
  Cell : ∀ {a b c d : Obj}, H a b → H c d → V a c → V b d → Prop

/-- Variant where the square/cell type is `Type` rather than `Prop`.  This is useful when we want to
keep explicit 2-cell witnesses as data. -/
structure DoubleCategoryDataT where
  Obj : Type u
  H : Obj → Obj → Type v
  V : Obj → Obj → Type v
  Cell : ∀ {a b c d : Obj}, H a b → H c d → V a c → V b d → Type w

namespace DoubleCategoryData

/-- The commutative-square cell predicate for a category `C`. -/
def commSqCell {C : Type u} [Category C] :
    ∀ {a b c d : C}, (a ⟶ b) → (c ⟶ d) → (a ⟶ c) → (b ⟶ d) → Prop :=
  fun {_ _ _ _} top bottom left right => CommSq top left right bottom

/-- Build `DoubleCategoryData` from a category by taking both horizontal and vertical morphisms
to be the category morphisms, and 2-cells to be commutative squares. -/
def ofCategory (C : Type u) [Category C] : DoubleCategoryData where
  Obj := C
  H := fun a b => a ⟶ b
  V := fun a b => a ⟶ b
  Cell := commSqCell

end DoubleCategoryData

/-! ## Specialization to SKY multiway paths -/

/-- The “square double category” data for the SKY multiway path category. -/
def skyPathDoubleData : DoubleCategoryData :=
  DoubleCategoryData.ofCategory MWObj

/-! ## Completion-homotopy squares -/

/-- A “weak” square predicate: the two boundary composites are related by completion homotopy. -/
def completionSqCell {a b c d : MWObj} (top : a ⟶ b) (bottom : c ⟶ d) (left : a ⟶ c) (right : b ⟶ d) :
    Prop :=
  CompletionHomotopy (LSteps.comp top right) (LSteps.comp left bottom)

/-- Double-category data for SKY paths where cells commute up to `CompletionHomotopy`. -/
def skyCompletionDoubleData : DoubleCategoryData where
  Obj := MWObj
  H := fun a b => a ⟶ b
  V := fun a b => a ⟶ b
  Cell := completionSqCell

/-! ## Completion 2-cells as data (Type-valued squares) -/

/-- Type-valued weak squares: a square commuting up to an explicit `Completion2Cell`. -/
def completionSqCellT {a b c d : MWObj} (top : a ⟶ b) (bottom : c ⟶ d) (left : a ⟶ c) (right : b ⟶ d) :
    Type :=
  Completion2Cell (LSteps.comp top right) (LSteps.comp left bottom)

/-- Double-category data for SKY paths where cells commute up to explicit completion 2-cells. -/
def skyCompletionDoubleDataT : DoubleCategoryDataT where
  Obj := MWObj
  H := fun a b => a ⟶ b
  V := fun a b => a ⟶ b
  Cell := completionSqCellT

/-! ## Sanity: our `PathHomotopy` is a special case of a commutative square -/

namespace PathHomotopy

open HeytingLean.LoF.Comb

/-- Any `PathHomotopy` determines a commutative square in the category of labeled paths,
with the special shape where the top and left edges share the same target. -/
def toCommSq {t u : Comb} {p q : LSteps t u} (h : PathHomotopy t u p q) :
    CommSq (C := MWObj)
      (W := ⟨t⟩) (X := ⟨u⟩) (Y := ⟨u⟩) (Z := ⟨h.v⟩)
      (f := p) (g := q) (h := h.r₁) (i := h.r₂) :=
  ⟨by simpa using h.comm⟩

end PathHomotopy

end Category
end Combinators
end LoF
end HeytingLean
